desc: MIDI ChordGen
author: sjrb
version: 1.0
about:
  MIDI Chord Generator.

  Play a note, and a chord is generated, per the requested root, scale & intervals.

  Scales are defined as Reaper scale .txt files, and should be in the ix_scales folder.
  This script assumes one scale per file.

tags: MIDI processing transposition transpose scales modes chords

slider1:0<0,11,1{C,C#/Db,D,D#/Eb,E,F,F#/Gb,G,G#/Ab,A,A#/Bb,B}>Root
slider2:/ix_scales:Major.txt:Scale
slider3:0<0,13,1{Played note,2,3,4,5,6,7,8,9,10,11,12,13,NA}>Scale pos above note
slider4:2<0,13,1{Played note,2,3,4,5,6,7,8,9,10,11,12,13,NA}>Scale pos above note
slider5:4<0,13,1{Played note,2,3,4,5,6,7,8,9,10,11,12,13,NA}>Scale pos above note
slider6:6<0,13,1{Played note,2,3,4,5,6,7,8,9,10,11,12,13,NA}>Scale pos above note
slider7:13<0,13,1{Played note,2,3,4,5,6,7,8,9,10,11,12,13,NA}>Scale pos above note
slider8:13<0,13,1{Played note,2,3,4,5,6,7,8,9,10,11,12,13,NA}>Scale pos above note
slider9:13<0,13,1{Played note,2,3,4,5,6,7,8,9,10,11,12,13,NA}>Scale pos above note

// pins - set to none when there is no audio
in_pin:none
out_pin:none

// init
// init - executed once on load & playback start
// init
@init
// Keep these safely away from each other...
scale=0;
chord_spos = 50;

// slider
// slider - executed whenever sliders change
// slider
@slider
root = slider1;
chord_spos[0] = slider3;
chord_spos[1] = slider4;
chord_spos[2] = slider5;
chord_spos[3] = slider6;
chord_spos[4] = slider7;
chord_spos[5] = slider8;
chord_spos[6] = slider9;

// block
// block - executed once per block
// block
@block

//
// functions - local to @block
//
function get_note_info(passed_note) (
  // Figure out chromatic offset from specified root
  passed_cpos = passed_note%12 - root;
  (passed_cpos < 0) ? (passed_cpos += 12);

  // Is it within our specified scale?
  // 0=false, 1=true
  note_info["in_scale"] = 0;
  note_info["spos"] = 0;
  note_info["cpos"] = passed_cpos;
  spos = -1;
  while ((note_info["in_scale"] == 0) && (spos <= scalesize)) (
    spos += 1;
    (passed_cpos == scale[spos]) ? (
      note_info["in_scale"] = 1;
      note_info["spos"] = spos;
    );
  );
  note_info;
);

// Build the chord, based on the user input and the location of the played note
// within the defined scale.
function spit_out_chord(note_info) (
  // Tied to the number of sliders we have to build the chord
  ix = -1;
  while (ix <= 6) (
    ix += 1;
    // Exclude NA (13)...
    (chord_spos[ix] < 13) ? (
      scale_position = note_info["spos"] + chord_spos[ix];
      // Need to account for exceeding the # of notes in the scale (e.g., a 9th is an octave + a 2nd)
      octs = floor(scale_position/scalesize);
      // Here's where we finally do the scale lookup...
      interval = scale[scale_position%scalesize];
      // Note the scales give you intervals relative to root, so you gotta offset from root...
      note = msg2 - note_info["cpos"] + (octs * 12) + interval;
      // Quick sanity check...
      ((note >= 0) && (note <= 127)) ? (
        midisend(mpos, msg1, note, msg3);
      );
    );
  );
);

//
// Main logic starts here...
//
while (midirecv(mpos, msg1, msg2, msg3)) (
  msg = msg1 >> 4;
  ((msg == 8) || (msg == 9)) ? (
    // Got a note!
    note_info = get_note_info(msg2);
    (note_info["in_scale"] == 1) ? (
      // In key logic...
      sprintf(#dbg_desc, "MIDI ChordGen");
      spit_out_chord(note_info);
    ):(
      // Not in key logic...
      sprintf(#dbg_desc, "Note played is not in the specified key!");
    );
  ):(
    // Not a note, send it on
    midisend(mpos, msg1, msg2, msg3);
  )
);

// serialize
// serialize - when reading or writing state
// serialize
@serialize

// Read scale file to memory... Can't have more than 12 notes in the scale...
memset(0,0,12);
scale=0;
fp=file_open(slider2);
scalesize=file_mem(fp,0,12);
file_close(fp);
